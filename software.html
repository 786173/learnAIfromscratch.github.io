<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-02-26 Wed 19:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Learn Programming from Scratch</title>
<meta name="generator" content="Org mode">
<meta name="author" content="jbh">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
   body {
    background-color: #ededed;
    margin: auto;
    padding: 0.5rem;
    max-width: 80ch; 
  }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Learn Programming from Scratch</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgff63702">Intro</a>
<ul>
<li><a href="#orgf045716">Code of Conduct</a></li>
<li><a href="#org432a21d">Study advice</a></li>
</ul>
</li>
<li><a href="#org4b009f4">Start here</a>
<ul>
<li><a href="#org579f908">Materials needed to complete this</a></li>
<li><a href="#org8c37f4b">Archiving the assignments (optional)</a></li>
</ul>
</li>
<li><a href="#org3b5aba7">Lecture 1 CS019</a>
<ul>
<li><a href="#org4f3de85">Reading PAPL</a></li>
<li><a href="#org5cecd07">Reading documentation</a>
<ul>
<li><a href="#orgd6aac2f">Methods</a></li>
</ul>
</li>
<li><a href="#org37ca11f">Reading chapter 2</a></li>
<li><a href="#org15c4051">Reading chapter 3</a></li>
</ul>
</li>
<li><a href="#org080ba32">Lecture 2 CS019</a>
<ul>
<li><a href="#orgdfa2a4a">Reading chapter 4</a>
<ul>
<li><a href="#orgd363a88">4.2.3 Exercise</a></li>
</ul>
</li>
<li><a href="#org0287c0c">Reading chapter 5</a></li>
<li><a href="#org5506ee7">Reading chapter 6</a></li>
<li><a href="#orgeef12b9">Assignment 1: DocDiff</a></li>
</ul>
</li>
<li><a href="#org8494242">Lecture 3 CS019</a>
<ul>
<li><a href="#orge9575a3">Lab: Higher-Order Functions</a></li>
</ul>
</li>
<li><a href="#org9e5620f">15-122 - Imperative Programming</a>
<ul>
<li><a href="#org98a23a4">Correct Code</a></li>
<li><a href="#org7d2ed87">Loops</a></li>
<li><a href="#org7190f29">Testing</a></li>
<li><a href="#orgf2e39b8">Proving Correctness</a></li>
<li><a href="#org23ea413">Arrays</a></li>
<li><a href="#org47a9647">Aliasing</a></li>
<li><a href="#orgac755cf">Searching and Sorting</a></li>
<li><a href="#org721a883">Complexity</a></li>
</ul>
</li>
<li><a href="#org99637f5">Cryptopals challenges</a></li>
<li><a href="#orga79c99f">Lecture 4 CS019</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orgff63702" class="outline-2">
<h2 id="orgff63702">Intro</h2>
<div class="outline-text-2" id="text-orgff63702">
<p>
This is a (ongoing) workshop to learn foundational programming skills in designing, writing and optimizing software and is Part IA of the so-called <a href="https://learnaifromscratch.github.io">AI Tripos</a>. The way these notes work is I do this material with you, and point out anything that may trip up a beginner who then is likely to just give up. The further we go on, the more terse the notes will get because I can then assume a background. The courses and books we will do promote that you try and figure out things for yourself as the only proven way to learn this material but their targeted audience is elite students who qualify to get into the <a href="https://en.wikipedia.org/wiki/Ivy_League">Ivy League</a> so we'll have to backtrack as we go filling in some holes in our education in the early lectures. 
</p>

<p>
If you know how to use a web browser you can start this curriculum, no expertise in software installation, programming or any other background is assumed. This means if you only own a phone or tablet, you can still complete this material. 
</p>
</div>

<div id="outline-container-orgf045716" class="outline-3">
<h3 id="orgf045716">Code of Conduct</h3>
<div class="outline-text-3" id="text-orgf045716">
<p>
Don't post your solutions to the assignments anywhere, such as keeping a public github with every assignment completed. Schools will hide them behind logins if too many solutions are posted. Some of the AI courses we'll see later the assignments have been restricted to the public. We'll work around this but it's annoying.    
</p>
</div>
</div>

<div id="outline-container-org432a21d" class="outline-3">
<h3 id="org432a21d">Study advice</h3>
<div class="outline-text-3" id="text-org432a21d">
<p>
Have the attitude you refuse to not know the material and you'll be fine. Try giving a lecture to an imaginary class from notes you took to prove you actually <a href="https://en.wikipedia.org/wiki/Grok#Adoption_and_modern_usage">grok</a> this material. If you can effortlessly explain the topic without stumbling over your words, using excessive jargon or forgetting your notes you can be assured you know the material. To get around the habit of jargon, imagine everytime you use jargon that somebody asks you to define precisely what it means and you have to stop your imaginary lecture and unravel technical language. 
</p>
</div>
</div>
</div>

<div id="outline-container-org4b009f4" class="outline-2">
<h2 id="org4b009f4">Start here</h2>
<div class="outline-text-2" id="text-org4b009f4">
<p>
We begin with Brown University's CS019 <i>Accelerated Introduction to Computer Science</i> which is 2 semesters combined into one and as a result omits some tedious analytical details you would find in regular classes that you can always research on your own should you later require those things. Look around the various course <a href="https://cs.brown.edu/courses/cs019/">pages</a>, like the <a href="http://cs.brown.edu/courses/csci0190/2019/README.html">readme</a>, and the notes about the <a href="http://cs.brown.edu/courses/csci0190/2019/policy.html#(part._.Unusual_.Assignments)">unusual assignments</a> which respects the intelligence of the student. Look around the instructor's <a href="https://cs.brown.edu/~sk/">page</a> like his manifesto on the current state of compsci education, and scroll through his <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/">papers</a>. Skim through the <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/rkf-student-ta-hours/paper.pdf">paper</a> on 'What Help Do Students Seek in TA Hours?' because it's from the exact course we are about to take. 'TA' is a teaching assistant, usually a student who did well in the course before. This is a quora <a href="https://www.mooclab.club/threads/what-does-professor-shriram-krishnamurthi-expect-a-student-to-know-after-he-she-works.4012/">post</a> about the book we'll do with the course from the writer/instructor "A person completing the first half is ready for most upper-level computer science". We're doing the entire book. 
</p>

<p>
There is a <a href="http://cs.brown.edu/courses/csci0190/2019/placement.html">placement</a> for the course but we're going to skip it, CS019 assumes no background and we have the luxury of time to fill in any blanks.   
</p>
</div>

<div id="outline-container-org579f908" class="outline-3">
<h3 id="org579f908">Materials needed to complete this</h3>
<div class="outline-text-3" id="text-org579f908">
<p>
As stated in the intro it's possible to complete this course with just a phone or a tablet
</p>
<ul class="org-ul">
<li>the <a href="https://papl.cs.brown.edu/2019/">book</a> <i>Programming and Programming Languages</i> (free)</li>
<li>a web browser to view the <a href="https://brown.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%222559ad35-3fff-4ef1-a2ac-a951011eb91e%22&amp;maxResults=50">lectures</a>
<ul class="org-ul">
<li>the lectures cover extra material not in the book</li>
</ul></li>
<li>a web browser to use the Pyret online <a href="https://www.pyret.org/set-sail/">interpreter</a></li>
<li>a google account to save your work if you wish</li>
<li>the 2018 copy of the <a href="https://cs.brown.edu/courses/cs019/2018/assignments.html">assignments</a> since we are watching the 2018 lectures</li>
<li>the labs at the bottom of this <a href="https://cs.brown.edu/courses/cs019/2016/assignments.html">page</a> (Big-O, Higher-Order Functions, Streams etc).</li>
</ul>
</div>
</div>

<div id="outline-container-org8c37f4b" class="outline-3">
<h3 id="org8c37f4b">Archiving the assignments (optional)</h3>
<div class="outline-text-3" id="text-org8c37f4b">
<p>
If you have <a href="https://en.wikipedia.org/wiki/Wget">wget</a> installed:
</p>
<pre class="example">
wget --mirror --convert-links --adjust-extension --page-requisites --no-parent https://cs.brown.edu/courses/cs019/2018/assignments.html
</pre>

<p>
You may also want to archive the pyret <a href="https://www.pyret.org/docs/latest/index.html">documentation</a> or even the entire <a href="https://papl.cs.brown.edu/2019/index.html">book</a> using the same method. To archive the lectures try a browser plugin that can download video content and save them as you watch or just wait until I upload them to academictorrents or some other archive should Brown kill access to them.
</p>
</div>
</div>
</div>

<div id="outline-container-org3b5aba7" class="outline-2">
<h2 id="org3b5aba7">Lecture 1 CS019</h2>
<div class="outline-text-2" id="text-org3b5aba7">
<p>
We're starting with the lecture titled <a href="https://brown.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=f53a52c3-2d36-406a-bde4-a952013df5e2">Wed 9/5/18</a>. Go to code.pyret.org and click <i>open editor</i> as you follow along the lecture. The book will cover everything he's doing like what a list is, what a function is, this is just a demonstration of the online interpreter. You can run Pyret <a href="https://www.pyret.org/set-sail/">offline</a> too. 
</p>

<p>
Notice he shuts down a lot of out of scope questions to not derail the lecture.  
</p>

<p>
@34:20 is the private app Exemplar which we don't have access to, and is usually an extra assignment on homework. The idea is that the students are given a task 'write a program that calculates the <a href="https://en.wikipedia.org/wiki/Median">median</a> of data in a list'. They start by writing the tests first before implementing the program, to get you to think about the problem. The exemplar app already has a working (and purposely buggy) implementation of the assignment that they can't see the source code for which is where the 'chaffs' are found (potential bugs caught). We will just have to write a lot of tests ourselves, covering enough cases until we've fleshed out the problem enough that we can go about implementing it. 
</p>

<p>
So how can we figure out the student given test cases for the median program? By looking up what a <a href="https://en.wikipedia.org/wiki/Median">median</a> is and the procedure to find it. Reading that article we see that the median is a value that seperates a finite list of numbers, that can be found by arranging them from the smallest to the greatest. If there is an odd number of entries, the middle number that splits the list into two even parts is picked. Otherwise it is defined to be the mean of the two middle values which means add them both and divide by 2, the idea being getting as close as possible to evenly splitting the data. That's why the test for [list: 1, 3, 2] is 2 because your program would reorder the list to be [list: 1, 2, 3] and choose 2 as the median. The Fermi problems he talks about must be released on Piazza which requires campus logins, <a href="https://piazza.com/class">https://piazza.com/class</a> is a kind of wiki/msg forum for courses that encourages anonymous postings so students don't feel embarassed to ask questions. A lot of universities now solely distribute their course materials through it meaning the public doesn't have access anymore. You can find these yourself online anyway by searching for Fermi problems. 
</p>

<p>
At the end he mentions the design recipe, as a way to save TAs time, explaining if you show up to office hours for help they will go about writing a template with the student, going through all the various stages and not just giving them an answer. He notes it is totally optional to use the design recipe, but it will help you with the hard assignments and if you're going to office hours with a lot of questions clearly your methods aren't working so why not try their method. If you read that <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/rkf-student-ta-hours/">paper</a> <i>What Help Do Students Seek in TA Office Hours</i> in the beginning of this workshop you'll see statistical results of the outcomes of students who used the design recipe vs those that didn't and their final grades. 
</p>

<p>
Templates are covered in the third lecture, it's a tool to extract 'code for free' from your data and will be useful for some of the assignments. 
</p>
</div>


<div id="outline-container-org4f3de85" class="outline-3">
<h3 id="org4f3de85">Reading PAPL</h3>
<div class="outline-text-3" id="text-org4f3de85">
<p>
Let's work through the <a href="https://papl.cs.brown.edu/2019/index.html">book</a> starting at the beginning, I'm using whatever the latest version is (as of this writing, 2019). This book is a work in progress so you'll see some minor errors like "REF" which is supposed to later be a link to whatever reference in the text that's not finished yet. The lectures we do will fill in these blanks.
</p>

<p>
Chapter 2 <i>Basic Data and Expressions</i> read while you have the pyret interpreter at code.pyret.org open. The examples with "&gt;" in front of them indicates enter this into the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>, on the right hand side of the pyret code editor like he did in the lecture pressing enter to eval. It's running a read-eval-print-loop (repl) which means exactly what you think it means. It reads input, evaluates it, prints it to the console and then loops back to waiting to read input again. You can increase the font size if you click the lambda skull logo on the top left side. 
</p>
</div>
</div>

<div id="outline-container-org5cecd07" class="outline-3">
<h3 id="org5cecd07">Reading documentation</h3>
<div class="outline-text-3" id="text-org5cecd07">
<p>
Already we are introduced to built-in functions, such as num-expt. To understand these, let's read the <a href="https://www.pyret.org/docs/latest/Builtins_and_Libraries.html">documentation</a>. If you have a small screen, you will need to turn your device to landscape or increase the browser window size in order to see the table of contents in the pyret docs which automatically hide depending on screen size and is annoying UI. 
</p>

<p>
Find the number functions <a href="https://www.pyret.org/docs/latest/numbers.html#(part._.Number_.Functions)">documentation</a> by hitting Ctrl-F in your browser or otherwise searching the page for 'num-expt'. Here is how you <a href="https://www.pyret.org/docs/latest/numbers.html#(part._numbers_num-expt)">read</a> it. The "::" syntax refers to type expected, so num-expt(base :: Number, exponent :: Number) -&gt; Number is annotation telling you this built-in requires two inputs: a base and an exponent of type number, and it outputs a number. This will be explained in chapter 3. Repeat looking in the documentation to understand what string-subtring() does. Try changing the examples yourself in the REPL as you go.
</p>
</div>

<div id="outline-container-orgd6aac2f" class="outline-4">
<h4 id="orgd6aac2f">Methods</h4>
<div class="outline-text-4" id="text-orgd6aac2f">
<p>
In the documentation under <a href="https://www.pyret.org/docs/latest/lists.html">lists</a> you will see additional built-in functions called methods. These have a dot notation such as .length() or .map(). What this means is the object itself, a list object, has features you can access directly. If your list is named my-list then you can access these by my-list.length() or by chaining them together, such as my-list.sort().length() to both sort and return the length of a list. Try this yourself in the REPL.
</p>
</div>
</div>
</div>

<div id="outline-container-org37ca11f" class="outline-3">
<h3 id="org37ca11f">Reading chapter 2</h3>
<div class="outline-text-3" id="text-org37ca11f">
<p>
The last section on roughnums, where irrational numbers like the square root of two return different values is due to floating point approximation that by default use a 'round to even' rounding strategy which if you wanted you could learn from this <a href="https://www.youtube.com/watch?v=XVg_tUyyQzA&amp;list=PL3swII2vlVoVspHvAYIvnbbqdV8oEuxkw&amp;index=5&amp;t=0s">lecture</a> but it assumes a technical background we don't have yet, namely that you've completed all the other lectures in that playlist and an introductory programming course, which we are doing right now. The final exercise <i>Do roughnums obey the axioms of arithmetic operators like distributivity, associativity and commutativity?</i> you can tell immediately from the examples in the book that roughnums are always returning different values, so a + b does not equal b + a if the numbers are roughnums. Think to yourself what would happen if you used floating point to encode money in financial software, with unpredictable results if some trade combination resulted in a roughnum. Oops
</p>
</div>
</div>

<div id="outline-container-org15c4051" class="outline-3">
<h3 id="org15c4051">Reading chapter 3</h3>
<div class="outline-text-3" id="text-org15c4051">
<p>
You spent all of chapter 2 entering commands into the REPL on the right hand side of the pyret online editor, now you'll use the left hand side to write functions and run them by either pressing Ctrl-Enter or the <i>Run</i> button. In 3.5 <i>Defining Functions in Steps</i> notice he changes the tests to not just return the expected value, but to return the expected computation, writing out in full what should be happening. The idea of doing this is to help you write the function. These aren't tests to prove it is correct, they are tests to help understand the full domain of the problem so we can write a model for it with software. 
</p>

<p>
I'm assuming you're doing all the exercises. Let's walk through the 'has-overtime' raises exercise.
</p>

<pre class="example">
fun has-overtime(hours :: Number) -&gt; Boolean:
  doc: "Returns true if hours &gt; 40 or returns false. Hours must be a positive number or error is raised"
  if hours &lt; 0:
    raise("hours must be greater than zero")
  else if hours &gt; 40:
      true
  else:
    false
  end
where:
  has-overtime(40) is false
  has-overtime(40.0001) is true
  has-overtime(-1) raises "hours must be greater than zero"
end
</pre>

<p>
Notice raise() is a built-in function. Where did I find how to use it? In the pyret language documentation. 
</p>

<p>
Let's write some tests for the last exercise hours-to-wages-ot as an example of how writing tests helps to define the problem better, and helps write the program for you. We have to write a function that consumes hours, an hourly rate, a threshold for OT, and returns anything over that threshold at 1.5 times the rate, adding it to the total pay. 
</p>

<p>
First, let's write the parameters:
</p>
<pre class="example">
fun hours-to-wage-ot(hours :: Number, rate :: Number, threshold :: Number) -&gt; Number:
  doc: "Calculates total pay with all hours over threshold at 1.5 the rate"
where:
end
</pre>
<p>
now let's write the tests:
</p>
<pre class="example">
where:
 hours-to-wage-ot(10, 1, 40) is 10 * 1
 hours-to-wage-ot(41, 1, 40) is (40 * 1) + (1 * (1 * 1.5))
 hours-to-wage-ot(50, 20, 48) is (48 * 20) + ((50 - 48) * (20 * 1.5))
end
</pre>

<p>
Keep writing test cases where you don't just write the final expected result, but how you would arrive at that result. Notice all I did here was copy the last test case, and the first test case to the function body:
</p>
<pre class="example">
fun hours-to-wages-ot(hours :: Number, rate :: Number, threshold :: Number) -&gt; Number:
  doc: "Calculates pay with all hours over threshold at 1.5 the rate"
  if hours &gt; threshold:
    (threshold * rate) + ((hours - threshold) * (rate * 1.5))
  else:
    hours * rate
  end
where:
  hours-to-wages-ot(10, 1, 40) is 10 * 1
  hours-to-wages-ot(41, 1, 40) is (40 * 1) + (1 * (1 * 1.5))
  hours-to-wages-ot(50, 20, 48) is (48 * 20) + ((50 - 48) * (20 * 1.5))
end
</pre>
</div>
</div>
</div>

<div id="outline-container-org080ba32" class="outline-2">
<h2 id="org080ba32">Lecture 2 CS019</h2>
<div class="outline-text-2" id="text-org080ba32">
<p>
Watch the Mon9/10/18 second lecture. Interesting lecture about the rainfall problem and the benefits of writing a lot of examples in order to understand badly defined problems. Data science/machine learning is brought up, as examples of dirty data. Higher-order functions are talked about, like filter and map which are in the pyret documentation. We're going to write our own versions of map, filter and fold after we cover Chapter 6 <i>Processing Lists</i>.
</p>
</div>


<div id="outline-container-orgdfa2a4a" class="outline-3">
<h3 id="orgdfa2a4a">Reading chapter 4</h3>
<div class="outline-text-3" id="text-orgdfa2a4a">
<p>
This is an interesting and short chapter how you would go about converting data to rows. There's nothing in here you can't already figure out now that you know how to read the documentation for pyret. The goal here is not to memorize all the built-in functions of Pyret but just gain extra experience changing the examples, and learning how to take data and make it into a program. The text also expects you to start reading documentation, not telling you how to assign a table to a variable so you can run all those sieve expressions on it. See the docs and change the examples in the text as you go to see what they do:
</p>

<pre class="example">
my-table = table: name, age
  row: "Alice", 30
  row: "Bob", 40
  row: "Carol", 25
end

sieve my-table using name:
  name == 'Carol'
end

order my-table:
  name ascending
end
</pre>

<p>
This is similar to <a href="https://n0x400.1mb.dev/#org268f85c">SQL syntax</a>, where you just declare what you want to do to rows and columns instead of how to do it. 4.2.6 selecting syntax is exactly like SQL syntax. Congrats you know some SQL now. In 4.2.7 the <i>principle of orthogonality</i> comment on why they composed these table row operations to be independent of each other so combining them in complex expressions is possible. 
</p>
</div>

<div id="outline-container-orgd363a88" class="outline-4">
<h4 id="orgd363a88">4.2.3 Exercise</h4>
<div class="outline-text-4" id="text-orgd363a88">
<p>
<i>Do Now</i> from 4.2.3. We are asked to think about how to write two questions, the first one is given to us so I tried the second which asks <i>Of the songs by a particular artist, which have we played the least often?</i>" using only what we've seen so far: 
</p>

<pre class="example">
my-playlist = 
  table: artist, song, playcount
    row: "Lustre", "The First Snow", 10
    row: "Lustre", "Green Worlds", 1
    row: "Lustre", "Welcome Winter", 2
  end

order my-playlist:
  playcount ascending
end
</pre>

<p>
Second Exercise <i>Write the second example as a composition of keep and order operations on a playlist table</i>.
</p>

<pre class="example">
my-playlist = 
  table: artist, song, playcount
    row: "Lustre", "The First Snow", 10
    row: "Lustre", "Green Worlds", 1
    row: "Lustre", "Welcome Winter", 2
  end

composition = order my-playlist:
  playcount ascending
end

sieve composition using playcount:
  playcount &lt;= 1
end
</pre>

<p>
Read ahead and play around with this, maybe you just want to return the song name, not the artist name and playcount, experiment with the documentation on your own:
</p>

<pre class="example">
my-playlist = 
  table: artist, song, playcount
    row: "Lustre", "The First Snow", 10
    row: "Lustre", "Green Worlds", 1
    row: "Lustre", "Welcome Winter", 2
  end

least-played = order my-playlist:
  playcount ascending
end

select song, playcount from least-played end
</pre>
</div>
</div>
</div>


<div id="outline-container-org0287c0c" class="outline-3">
<h3 id="org0287c0c">Reading chapter 5</h3>
<div class="outline-text-3" id="text-org0287c0c">
<p>
In 5.3.1 the description of the properties of an 'anonymous value' abstraction by using numbers and asking what they mean is similar to Terence Tao's <i>Linear Algebra</i> text where he points out that a property of numbers that makes them useful is their ability to be interpreted differently depending on context. 
</p>

<p>
A <i>Do Now</i> appears. This means we should actually do it. Try to sieve our playlist to show the most played song using built-in language functions from the math or statistics library: 
</p>

<pre class="example">
include math

my-playlist = 
  table: artist, song, playcount
    row: "Lustre", "The First Snow", 10
    row: "Lustre", "Green Worlds", 1
    row: "Lustre", "Welcome Winter", 2
  end

play-count = extract playcount from my-playlist end
most-played-count = max(play-count)

sieve my-playlist using playcount:
  playcount == most-played-count
end
</pre>

<p>
Lists are introduced, which is the datastructure we will be using for a lot of the exercises. 
</p>

<p>
Important: the Exercise in 5.4.2 <i>Implement all the other statistical questions posed in Basic Statistical Questions</i> is mandatory. They look easy after reading the book examples, and you definitely will think to yourself 'oh I already know this, time to move on' but you only learn by doing. Remember experts in learning have constructed this book and course and know exactly what you need to do in order to be successful in completing it. There will always be one or two questions in there that will stump you a little and require research to solve the exercise and when you figure it out you will never forget how you found that solution whereas if you skip this exercise, you'll promptly forget in a few days time. So let's look at them:
</p>

<p>
'keep-if' likely is supposed to be sieve as per 4.2.1 Keeping or another command you write to filter a table and keep results. Remember the warning from 1.3 The Structure of This Book: <i>"We will include mistakes, not because we don’t know better, but because this is the best way for you to learn. Including mistakes makes it impossible for you to read passively: you must instead engage with the material, because you can never be sure of the veracity of what you’re reading"</i>. 
</p>

<p>
Let's go through 5.1 <i>Basic Statistical Questions</i> but using our my-playlist as an example. These will all be functions on lists, because we use the extract built-in function to remove this information from a table and returns a list.
</p>

<pre class="example">
# notice these import statements so we can use these built-in function
include math
include statistics
import lists as L

my-playlist = 
  table: artist, song, playcount
    row: "Lustre", "The First Snow", 10
    row: "Lustre", "Green Worlds", 1
    row: "Lustre", "Welcome Winter", 2
  end

# From 5.1 Basic Stat Questions:
# Question 1, 2, and 3 are the same: the maximum or largest value
# To see what these datastructures look like, type 'play-count' into REPL
play-count = extract playcount from my-playlist end
most-played-count = max(play-count)

sieve my-playlist using playcount:
  playcount == most-played-count
end

# Smallest value in a column 
least-played-count = min(play-count)

# Number of songs in a playlist
# Since we have extracted a list, we just need to count the length of the list using a built-in function
# using: play-count = extract playcount from my-playlist end
play-count.length()

# All the distinct entries in playcount column
# Another built-in from lists documentation
# Notice import lists as L, you can call this something else 'import lists as whatever' 
L.distinct(play-count)

# The number of distinct entries in a playcount column
# Asking us: count how many entries are distinct
# Note we are chaining built-ins together here:
L.distinct(play-count).length()

# The average, this is another built-in, from this exact chapter
avg-play-count = mean(play-count)

# Other statistics
# Just replace x(play-count) with that built-in from the statistics library 
modes-play-count = modes(play-count)
median-play-count = median(play-count)
stdev-play-count = stdev(play-count)
</pre>

<p>
That was a little tedious but it taught us how to look up documentation, how to use import or include statements.
</p>
</div>
</div>

<div id="outline-container-org5506ee7" class="outline-3">
<h3 id="org5506ee7">Reading chapter 6</h3>
<div class="outline-text-3" id="text-org5506ee7">
<p>
We need to understand this chapter to follow along with the rest of the lectures, and for future assignments. 6.1 you can type all those examples in the REPL to see what they do, like manually linking a list together with link. 
</p>



<p>
6.2 Let's make some list functions:
</p>

<pre class="example">

# Examples first. List&lt;Any&gt; means will accept any type (string, number)
# Length only counts the number of items, not nested list items:
fun my-len(l :: List&lt;Any&gt;) -&gt; Number:
  doc:"Returns the length of a list"
  check:
    my-len([list: ]) is 0
    my-len([list: 1, 2, 3]) is 3
    my-len([list: 1, [list: 1, 2], 99]) is 3
    my-len([list: [list: empty], 1]) is 2
  end
end

# From these examples we can build the function:
fun my-len(l :: List&lt;Any&gt;) -&gt; Number:
  doc:"Returns the length of a list"
  cases (List) l:
    | empty =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end
check:
  my-len([list: ]) is 0
  my-len([list: 1, 2, 3]) is 3
  my-len([list: 1, [list: 1, 2], 99]) is 3
  my-len([list: [list: empty], 1]) is 2
end
</pre>

<p>
This is how my-len() is evaluated if you call my-len() with list 1, 2, 3:
</p>

<ul class="org-ul">
<li>my-len([list: 1,2,3])</li>
<li>1 + my-len([list: 2, 3])</li>
<li>1 + (1 + my-len([list: 3]))</li>
<li>1 + (1 + (1 + my-len([list: empty])))</li>
<li>1 + 1 + 1 + 0 
<ul class="org-ul">
<li>= 3</li>
</ul></li>
</ul>


<p>
Let's do another 6.2 list exercise:
</p>
<pre class="example">
# Compute the sum of a list (of numbers)
# Start with examples, and run your examples just to make sure they are well formed/syntax
fun my-sum(l :: List&lt;Number&gt;) -&gt; Number:
  doc: "Returns the sum of numbers in a list"
  check:
    my-sum([list: ]) is 0
    my-sum([list: 1, 2, 3]) is 6
    my-sum([list: -1, -2]) is -3
    my-sum([list: [list: ], [list: 2, 3], 3]) is 8
    my-sum([list: 2]) is 2
  end
end

# Let's try and write this
fun my-sum(l :: List&lt;Number&gt;) -&gt; Number:
  doc: "Returns the sum of numbers in a list"
  cases (List) l:
    | empty =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end
  check:
    my-sum([list: ]) is 0
    my-sum([list: 1, 2, 3]) is 6
    my-sum([list: -1, -2]) is -3
    my-sum([list: [list: ], [list: 2, 3], 3]) is 8
    my-sum([list: 2]) is 2
  end

</pre>

<p>
One test failed! It didn't count the nested list. We weren't expected to write functions that can handle deeply nested lists or anything, but for learning purposes let's see if we can anyway. What does the built-in sum return:
</p>

<pre class="example">
import math
sum([list: 3, 3, [list: 2, 3]])
</pre>

<p>
It fails too, so let's clean the data first 
</p>

<pre class="example">
import lists as L

fun my-sum(l :: List&lt;Number&gt;) -&gt; Number:
  doc: "Returns the sum of numbers in a list"
  cases (List) l:
    | empty =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end
check:
  my-sum([list: ]) is 0
  my-sum([list: 1, 2, 3]) is 6
  my-sum([list: -1, -2]) is -3
# new call here:
  my-sum(clean-data([list: ], [list: [list: ], [list: 2, 3], 3])) is 8
  my-sum([list: 2]) is 2
end

# .filter() function no-empty is below
# is-link is built-in, see documentation
fun clean-data(l1 :: List&lt;Any&gt;, l2 :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  doc: "Removes nested lists, call with clean-data(empty-list, list-to-clean)"
  cases (List) l2:
    | empty =&gt; l1.filter(no-empty)
    | link(f, r) =&gt;
      if is-link(f):
        temp = L.append(l1, f)
        clean-data(temp, r)           
      else:
        temp = l1.push(f)
        clean-data(temp, r)
      end
  end
end

# .filter(function) if boolean == true then only those items will be returned
fun no-empty(l3 :: List&lt;Any&gt;) -&gt; Boolean:
 doc: "Predicate for empty case clean-data() filter"

# try to implement yourself, could even do if is-empty(l3): false else: true 
end
</pre>
<p>
How clean-data() evals is test if f == a list structure, if it does we append the entire embedded list to an accumulator, and then loop again with the accumulator now becoming parameter 'l1' input. On the empty case you return the accumulator, which here is l1 filtered to remove any [list: empty] using the .filter() built-in you can read about in the documentation. Try implementing the rest of the functions in 6.2 as the more practice you have doing this the easier the lectures and assignments will be. Note this is not an efficient solution, just it's the easiest demonstration. 
</p>

<p>
If this doesn't make sense step by hand through clean-data():
</p>

<ul class="org-ul">
<li>clean-data(l1, list-to-clean)
<ul class="org-ul">
<li>l1 is empty when first called</li>
</ul></li>
<li>is f == to a list datastructure? if so append the whole embedded list to temp-list and loop again</li>
<li>clean-data(temp-list, rest-of-list-to-clean)
<ul class="org-ul">
<li>temp-list is now l1</li>
</ul></li>
<li>if f is not an embedded list, then push the value of f to l1 and assign it to temp-list again</li>
<li>if we reach end of list-to-clean, filter for any empties and return l1, the fully cleaned list</li>
</ul>
</div>
</div>


<div id="outline-container-orgeef12b9" class="outline-3">
<h3 id="orgeef12b9">Assignment 1: DocDiff</h3>
<div class="outline-text-3" id="text-orgeef12b9">
<p>
Let's try the first <a href="https://cs.brown.edu/courses/cs019/2018/docdiffdocdiff.html">assignment</a>. One way to slog through a long chapter on list functions is to actually implement something using lists, then we can refer to it as reference. In other words it becomes a research project to read that we are more motivated to do since we're trying to complete a task. You could also try watching Lecture 3 first before doing this assignment if you're unsure of how recursion on lists works. 
</p>

<p>
This assignment looks difficult on purpose but is easy to implement. You're just translating instructions. The <a href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition">dot product</a> algebraic definition, look at the example for [1,3,-5] x [4,-2,-1]. Each index in the first list is multiplied by it's corresponding index in the second list, then those results are added together. To read the sigma notation, a*b = the sum of \(a_ib_i\) starting at index 1 (first element of the list) up to the length of the list (n):
</p>

<details>
<p>
If a = [1, 3, -5] and b = [4, -2, -1]:
</p>

<p>
\(a*b = \sum_{i=1}^3 a_ib_i\) = (\(1_{a1} * 4_{b1})+(3_{a2} * -2_{b2})+(-5_{a3} * -1_{b3})\)
</p>
</details>

<p>
Some more requirements are listed, such as ignoring the case (upper/lower) of a letter when counting it's number of occurences. The exact equation for overlap is given: dot-product(doc1, doc2) / num-max(num-sqr(magnitude(doc1)), num-sqr(magnitude(doc2))) assuming you converted both doc1/doc2 to vectors already.  
</p>

<p>
Example vectors:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">test</td>
<td class="org-right">zest</td>
</tr>

<tr>
<td class="org-left">[list: "test"]</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">[list: "zest"]</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<pre class="example">
import lists as L

fun overlap(doc1 :: List&lt;String&gt;, doc2 :: List&lt;String&gt;) -&gt; Number:
# fill this in, it's just basic staging, no loops
end
check:
  overlap([list: "same"], [list: "same"]) is 1
  overlap([list: "not"], [list: "same"]) is 0
end

fun create-vec(doc1 :: List&lt;String&gt;, all-words :: List&lt;String&gt;) -&gt; List&lt;Number&gt;:
  doc: "Consumes a document of words, produces a vector"
  cases (List) all-words:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if doc1.member(f):
        link(count(f, doc1, 0), create-vec(doc1, r))
      else:
        link(0, create-vec(doc1, r))
      end
  end
end

fun count(word :: String, doc1 :: List&lt;String&gt;, acc :: Number) -&gt; Number:
  doc: "Counts the occurences of word in doc"
# You can easily complete this using an accumulator (see Chapter 6 of PAPL)
end

fun uniq-words(doc1 :: List&lt;String&gt;, doc2 :: List&lt;String&gt;) -&gt; List&lt;String&gt;:
  doc: "Returns a list of all unique words between two documents"
# You can use built-ins for this, see the pyret List documentation
end
  
fun dot-product(acc :: Number, vec1 :: List&lt;Number&gt;, vec2 :: List&lt;Number&gt;) -&gt; Number:
  doc: "Multiplies each index of vec1 with vec2, sums the results"
  cases (List) vec1:
    | empty =&gt; acc
    | link(f, r) =&gt;
      cases (List) vec2:
        |link(ff, rr) =&gt;
          temp-count = acc + (f * ff)
          dot-product(temp-count, r, rr)
      end
  end
end

fun magnitude(doc-vec :: List&lt;Number&gt;) -&gt; Number:
  doc: "Returns the norm of doc-vec"
  num-sqrt(dot-product(0, doc-vec, doc-vec))
end
</pre>

<p>
I almost posted too much of the answer, breaking my own rule on not posting answers so they don't lock away the assignments. Note my implementation is missing tests, doesn't follow the whole requirements (such as upper/lower case ignoring) and doesn't follow the Pyret <a href="https://www.pyret.org/docs/latest/Pyret_Style_Guide.html">style guide</a>. This assignment is much shorter and easier to do with higher-order functions, which we will take shortly. 
</p>
</div>
</div>
</div>

<div id="outline-container-org8494242" class="outline-2">
<h2 id="org8494242">Lecture 3 CS019</h2>
<div class="outline-text-2" id="text-org8494242">
<p>
We're watching Wed9/12/18 lecture on sorting. These videos you can download in 1920x1080 if you want and zoom if you can't see the writing on the whiteboard. 
</p>

<p>
He walks through exactly what a template is and how to extract data to make a template, and spends the rest of the class writing insertion sort using only what we already know so far. You have to hand step through it a little to understand what insertion sort is doing. Function sort() is calling insert() with insert(f, sort(r)) it isn't calling insert(f, r) to just hand it the rest of the list. 
</p>

<p>
Let's step the evaluation by hand with [list: 0, 1, 3, 2] being input to sort(). The following calls to insert happen:
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3,(insert(2, [list: empty])))))))</li>
</ul>

<p>
It's like our example with my-len() with 1 + 1 + etc. Evaluation starts at the deepest inner bracket:
</p>

<ul class="org-ul">
<li>insert(2, [list: empty])
<ul class="org-ul">
<li>is list empty? link(2, link(empty))</li>
<li>return to sort(): [list: 2, empty]</li>
</ul></li>
<li>insert(3, [list: 2, empty])
<ul class="org-ul">
<li>is 3 &lt; 2?</li>
<li>link(2, insert(3, [list: empty]))</li>
<li>return to sort(): [list: 2, 3, empty]</li>
</ul></li>
<li>insert(1, [list: 2, 3, empty])
<ul class="org-ul">
<li>is 1 &lt; 2?</li>
<li>then it must the smallest in the entire list:</li>
<li>link(1, [list: 2, 3, empty])</li>
<li>return to sort(): [list: 1, 2, 3, empty]</li>
</ul></li>
<li>insert(0, [list: 1, 2, 3, empty])
<ul class="org-ul">
<li>is 0 &lt; 1?</li>
<li>link(0, [list: 1, 2, 3, empty])</li>
<li>return to sort(): [list: 0, 1, 2, 3, empty]</li>
</ul></li>
<li>no more delayed computations, sort() is finished</li>
</ul>

<p>
The returns to sort():
</p>

<ul class="org-ul">
<li>insert(0,(insert(1,(insert(3, [list: 2, empty])))))</li>
<li>insert(0,(insert(1, [list: 2, 3, empty])))</li>
<li>insert(0, [list: 1, 2, 3, empty])</li>
</ul>

<p>
Everytime a list is returned, the next call to insert can happen because it is complete with insert(n, list).
</p>
</div>

<div id="outline-container-orge9575a3" class="outline-3">
<h3 id="orge9575a3">Lab: Higher-Order Functions</h3>
<div class="outline-text-3" id="text-orge9575a3">
<p>
Let's do the <a href="https://cs.brown.edu/courses/cs019/2016/hofs-lab.pdf">lab</a> on functions as data, and write our own map, filter and fold. 
</p>

<pre class="example">
fun fun-plus-one(num :: Number, func :: (Number -&gt; Number)) -&gt; Number:
  func(num) + 1
end

&gt;&gt;fun-plus-one(16, num-sqr)
&gt;&gt;5
</pre>

<p>
Try entering various built-ins, or one you wrote yourself, as the second parameter to fun-plus-one.
</p>

<p>
<b>Map</b>
</p>

<p>
We're given test cases and asked to implement f-to-c and goldilocks, and given the formula for f to c temperature unit conversion.
</p>

<pre class="example">
fun f-to-c(f-lst :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt; 
      link((f - 32) * (5/9), f-to-c(r))
  end
end

fun goldilocks(f-lst :: List&lt;Number&gt;) -&gt; List&lt;String&gt;:
  cases (List) f-lst:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 90:
        link("too hot", goldilocks(r))
      else if f &lt; 70:
        link("too cold", goldilocks(r))
      else:
        link("just right", goldilocks(r))
      end
  end
end
check:
  f-to-c([list: 131, 77, 68]) is [list: 55, 25, 20]
  goldilocks([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
We're asked to rewrite goldilocks using map. The data dumped into a map function is whatever the value is at that list index. In this case we know it's a number since f-lst parameter is :: List&lt;Number&gt;.
</p>

<pre class="example">
fun goldilocks2(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  f-lst.map({(x): if x &gt; 90: "too hot" else if x &lt; 70: "too cold" else: "just right" end})
end
check:
  goldilocks2([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
.map() is a built-in method on a list, where f-lst.map() means we are mapping over f-lst. I used the shorthand syntax for lambdas.
</p>

<p>
We could have also rewritten it like the following example, where a seperate function is used for map instead of writing our own lambda:
</p>

<pre class="example">
fun goldilocks(x :: Number) -&gt; String:
  if x &gt; 90:
    "too hot"
  else if x &lt; 70:
    "too cold"
  else:
    "just right"
  end
end

fun goldilocks2(f-lst :: List&lt; Number&gt;) -&gt; List&lt;String&gt;:
  map(goldilocks, f-lst)
end
check:
  goldilocks2([list: 131, 77, 68]) is [list: "too hot", "just right", "too cold"]
end
</pre>

<p>
Now our task is write our own version of map(). I just used the documentation examples for map as check tests. Remember map consumes a function and a list, applies the function to each entry in the list returning a new list, try to do this yourself before looking at a solution (your solution may be better). For annotations, I used the <a href="https://www.pyret.org/docs/latest/s_annotations.html#(part._s~3aname-ann)">built-in</a> name annotations but if you read through the documentation you can also import annotations, or create your own datatype. 
</p>

<details>
<pre class="example">
fun my-map(func :: (Any -&gt; Any), l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(func(f), my-map(func, r))
  end
end
check:
  my-map(num-tostring, [list: 1, 2]) is [list: "1", "2"]
  my-map(lam(x): x + 1 end, [list: 1, 2]) is [list: 2, 3]
end
</pre>
</details>

<p>
<b>Filter</b>
</p>

<p>
First two assignments are straight forward to get you to used to using filter, except you have to use string-to-code-points() instead of any built-in string functions. 
</p>

<details>
<pre class="example">
fun tl-dr(lol :: List&lt;Any&gt;, length-thresh :: Number) -&gt; List&lt;Any&gt;:
  filter(lam(element): string-to-code-points(element).length() &lt;= length-thresh end, lol)
end
check:
  tl-dr([list: "dkfjdkj", "hi", "dkfjk"], 2) is [list: "hi"]
  tl-dr([list: "corner", "case", ""], 2) is [list: ""]
  tl-dr([list: "a", "b", "c"], 0) is [list: ]
end

# I got '101' from entering string-code-points("e") in the REPL
# See comments below, you would not want to write code this way
fun eliminate-e(words :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  filter(lam(element): if string-to-code-points(element).member(101) or
    string-to-code-points(element).member(69): false else: true end end, words)
end
check:
  eliminate-e([list: "e"]) is [list: ]
  eliminate-e([list: "there's", "no", "letter", "e", "here"]) is [list: "no"]
  eliminate-e([list: "hello", "everybody"]) is [list: ]
  eliminate-e([list: "E", "101", "!!!"]) is [list: "101", "!!!"]
end

</pre>
</details>

<p>
A much cleaner way to implement eliminate-e() would be to filter once extracting all the strings in the list with "e" and/or "E" in them, then filter again and using that list as a predicate to filter the original. Lambda identifiers should be short: filter(lam(x): x &gt; 1 end) as it's immediately evident what that parameter is, as the 'scope' of that function is only the filter. Try writing that better solution. 
</p>

<p>
Task: implement our own version of filter, which is similar to what we did for map:
</p>

<details>
<pre class="example">
fun my-filter(func :: (Any -&gt; Boolean), l :: List&lt;Any&gt;) -&gt;List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if func(f):
        link(f, my-filter(func, r))
      else:
        my-filter(func, r)
      end
  end
end
check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  my-filter(length-is-one, [list: "ab", "a", "", "c"]) is [list: "a", "c"]
  my-filter(is-link, [list: empty, link(1, empty), empty]) is [list: link(1, empty)]
end
</pre>
</details>

<p>
<b>Fold</b>
</p>

<p>
The two tasks: list-product and list-max should be easy for you by now:
</p>

<details>
<pre class="example">

fun list-product(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): acc * n end, 1, lon)
end
check:
  list-product([list: 2, 2, 2]) is 8
  list-product([list: 0, 1, 2]) is 0
  list-product([list: -1, -1]) is 1
end

fun list-max(lon :: List&lt;Number&gt;) -&gt; Number:
  fold(lam(acc, n): if n &gt; acc: n else: acc end end, 0, lon)
end
check:
  list-max([list: -1, 1, 2]) is 2
  list-max([list: 0, -100, 1]) is 1
  list-max([list: 1/2, 3/4]) is 3/4
end
</pre>
</details>

<p>
Try implementing fold yourself before you look at my solution, use the check tests for fold in the pyret documentation to test your solution.
</p>

<details>
<pre class="example">
fun my-fold(func :: (Any -&gt; Any), acc :: Any, l :: List&lt;Any&gt;) -&gt; Any:
  cases (List) l:
    | empty =&gt; acc
    | link(f, r) =&gt;
      temp = func(acc, f)
      my-fold(func, temp, r)
  end
end
check:
  my-fold((lam(acc, elt): acc + elt end), 0, [list: 3, 2, 1]) is 6
  my-fold((lam(acc, elt): acc + elt end), 10, [list: 3, 2, 1]) is 16
  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  my-fold(combine, "END", [list: 3, 2, 1]) is "1 - 2 - 3 - END"
  my-fold(combine, "END", empty) is "END"
end
</pre>
</details>

<p>
<b>Map2</b>
</p>

<p>
The task for implementing who-passed is straight forward to figure out, the second task we're asked to write map2 ourselves. 
</p>

<details>
<pre class="example">

# link(ff, rr) and link(f, r) can be called anything:
# ie: link(head-first, tail-first) or link(head-second, tail-second)
fun my-map2(func :: (Any -&gt; Any), list1 :: List&lt;Any&gt;, list2 :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) list1:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) list2:
        | empty =&gt; empty
        | link(ff, rr) =&gt;
          link(func(f, ff), my-map2(func, r, rr))
      end
  end
end
check:
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(_ + _, [list: "mis", "mal"], [list: "fortune", "practice"])
    is [list: "misfortune", "malpractice"]
  my-map2(string-append, [list: "mis", "mal"], [list: "fortune"])
    is [list: "misfortune"]
  my-map2(string-append, [list: "mis", "mal"], empty)
    is empty
end
</pre>
</details>

<p>
The last task, best-price, look on youtube what a basic demand function is. Here's an example:
</p>

<pre class="example">
fun demand(price-increase :: Number) -&gt; Number:
 doc: "1000 is approx demand of product at a fixed price"
  1000 - (60 * price-increase)
end
</pre>

<p>
This means as the price increases, the quantity demanded will decrease by 60 units times the price increase, so if the price increase is 1, the demand is 1000 - 60. Your best-price function can take a list of price increases, the demand function, then map over the price list w/the demand function, to get a new list of adjusted demand vs price increase. Map over the adjusted demand with the price list to produce the forecast revenue, which is price * qty demanded. Then figure out how to use a combo of filter/fold in order to return just the optimal price increase or write a helper function, inside the best-price function for the higher-order functions to use. The reasons for using a helper function is so you get access to the scope of the parent function, so any locally lived variables in that parent function you can pass into the helper function. 
</p>
</div>
</div>
</div>


<div id="outline-container-org9e5620f" class="outline-2">
<h2 id="org9e5620f">15-122 - Imperative Programming</h2>
<div class="outline-text-2" id="text-org9e5620f">
<p>
In the next lecture of cs019, we will cover how to estimate complexity of a program, and then apply that to all future lectures and assignments. Here we will do the same, learn about how reasoning with contracts can help us write better code and then apply it to all future code. We will also learn exactly how numbers are represented in a computer, which is everyday knowledge we should know when later we have to work in Python for an AI course.  
</p>

<p>
Register <a href="https://oli.cmu.edu/jcourse/webui/register/student.do">here</a> free to Carnegie Mellon University's open learning initiative, and use the course key: imp2019f (this course can also be completed with only a phone).
</p>

<p>
Click on <a href="https://oli.cmu.edu/jcourse/lms/students/syllabus.do?last=entry&amp;section=cf8f60f80a0001dc13d6d1a95a068126">Enter Course</a> and you should see Syllabus: 15-122 Imperative Programming Aug-Dec 2019. It consists of three units on integers (how two's complement works, bit shifting) and one unit on contracts which is a method for ensuring correctness. One of the professors has a short talk <a href="https://www.youtube.com/watch?v=lNITrPhl2_A">here</a> outlining the benefits of contracts. 
</p>

<p>
Let's start with Unit 2, Module 5: <a href="https://oli.cmu.edu/jcourse/webui/syllabus/module.do?context=cf8f63420a0001dc1bb09fcd7fd784a2">Representing Integers</a>.
</p>

<p>
The Hindu-Arabic numeral system is introduced which if you've taken the <a href="https://learnaifromscratch.github.io/math.html">math</a> foundations beside this programming workshop you already know about. The summation notation for converting binary numbers to decimals: below the sigma (the greek E symbol, which means sum) is the starting index 0. Above the sigma is the range, which is n - 1 since we are beginning at zero, if you wish to sum 4 binary numbers then you want 0 through 3 (0, 1, 2, 3 is 4 digits). \(b_i2^i\) is where you plug in the starting index. The b variable (base) is either 0 or 1 since this is binary:
</p>

<p>
\(b_{0}2^0 + b_{1}2^1 + b_{2}2^2\)&#x2026; for binary number 0101 is (1 * \(2^0\))+(0 * \(2^1\))+(1 * \(2^2\))+(0 * \(2^3\)) as you start from the right of the binary number and sum left. This will make sense when you do the 'do now' exercise.
</p>

<p>
Horner's rule you evaluate by starting with the deepest nested brackets and working to the right. The example you eval the multiplication first then addition: (2 + 1) x 2 x 2 x 2 x 2 (+ 1) which is 3 x 2 (6) x 2 (12) x 2 (24) x 2 (48) + 1 = 49.  
</p>

<p>
Try the interactive assignment then move on to <a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=cf8f63450a0001dc67eab637081785cd">Adding Binary Numbers</a>. The bit carry you start at the top and work down, so if you have three 1's (a carried bit), then it's 1 + 1 = 0 (carry over a 1), 0 + 1 = 1. Hexadecimal representation is next, the 'did I get this' questions are great for understanding how the 0x notation works, for example 0x10 is 00010000 or 2\(^4\). 
</p>

<p>
We're now on module 6, fixed-precision integers. C0 is pronounced 'c-naught' and is <a href="http://c0.typesafety.net/">similar</a> to C. Note for these assignments if you want more practice, click on reset to keep feeding yourself new questions. There's a typo in <i>Division and Modulus</i>, it should read 9/4 = 2 and the remainder 9 % 4 = 1 for (x / y) * y + (x % y) = x. 
</p>

<p>
The rounding unit points out that Python uses the round to negative infinity rounding strategy. Try some of the examples yourself: (-7) / 3 = -2.333&#x2026; and the strategy for rounding towards O is truncate -2.333 to -2 while rounding to negative infinity you would decrease to -3 instead. Let's explain to ourselves the difference in mod operators too where rounding towards 0 for (-8) % 5 = -3 while rounding towards negative infinity results in -2. The Java/C model (towards 0), you multiply 5 by -1 and the remainder from -5 to -8 is -3. In the Python/negative infinity model, you are finding the lowest multiple of 5, which is less than -8, so 5 x (-2) = -10. The modulus is then the distance between -10 and -8, which is +2. The important takeaway here is to always read the documentation/specs of whatever language you're using, to understand how it's number representation works for integers, floats, etc. 
</p>

<p>
Now we're on module 7 <i>Bit Patterns</i>. The AND operation against a mask such as 0xFF will leave every byte unchanged since if you look at the boolean table if the original bit is 0 or 1 then it will still be 0 or 1. The boolean most significant bit example of 0x80000000 remember 8 in hex is 1000. Let's go through the Bitwise negation example to understand it but with only 8 bytes. Assume x's current state is 0000 0001 everything is off except the first bit, using their home automation model where 1 bit represents a light switch. We want to toggle bit 5, the dining room light: 
</p>

<ul class="org-ul">
<li>0x20 = 0010 0000</li>
<li>&amp; ~x = 1111 1110
<ul class="org-ul">
<li>dr = 0010 0000</li>
</ul></li>
<li>0xDF = 1101 1111</li>
<li>&amp;x   = 0000 0001
<ul class="org-ul">
<li>others = 0000 0001</li>
</ul></li>
<li>dr | others = 0010 0001</li>
</ul>

<p>
Module 7 <i>Relating Arithmetic and Bitwise Operations</i> what they are describing is 'complement and increment' as a way to change any binary number to it's negative two's complement representation. The left shift exercise when you look at the answer notice they are shifting around the 1/3 values of blue then using OR to put them all back together into 32bits. The right shifting unit, there's a problem with the answer for 0xC0C0FFEE &gt;&gt; 20 it should be 0xFFFFFC0C but it doesn't recognize it as correct. The last one you have to manually write out the bits, arithmetically shift (padding 1's) to the right 7 bits, then reassemble them from left to right into groups of 4, truncating the furthest right 7 bits to get the answer.   
</p>
</div>

<div id="outline-container-org98a23a4" class="outline-3">
<h3 id="org98a23a4">Correct Code</h3>
<div class="outline-text-3" id="text-org98a23a4">
<p>
We're now on module 1 <i>Preconditions - When Do Errors Show up?</i> which is the bulk of 15-122, analyzing imperative code and reasoning about it's correctness. You use code commenting to describe the behavior or a function, and these comments are called contracts. The compiler can statically check these contracts meaning the code is not running, or some languages have the ability to run the code with these contracts enforced, such as JML(Java), Clojure.spec, and C0. If you watched the <a href="https://youtu.be/lNITrPhl2_A">talk</a> ex CMU prof Simmons gave about contracts I posted earlier in these notes, you'll see that extensive testing covers less than 1% of the field of potential inputs. That same talk he also points out contracts have benefits even for functional languages with strong typing (we'll learn these later too) and briefly gives an idea about dependent types as a replacement for contracts, something we'll also briefly cover later.   
</p>


<p>
In <i>When Do Errors Show Up?</i> the example <i>string attach(int n, char c, string str)</i> int, char, and string are similar to Pyret type notations describing what inputs they should accept. Some of the exercises assume syntax knowledge like a char must be in single quotes ie: 'c' (char) vs "c" (string) but otherwise the syntax is easy enough to figure out just by looking at it, and if you make a simple syntax error the system still gives you the correct answer anyway. Module <i>What 'Safety' Means in C0</i> the first learn by doing you're just entering statements like n &gt;=0 &amp;&amp; n &lt;=12. The equality boolean is n == 0 (double equal, single is assignment like Pyret). 
</p>

<p>
Moving on to Module 2 <a href="https://oli.cmu.edu/jcourse/workbook/activity/page?context=cf8f62f90a0001dc4733a1faff094884">Assertions</a>. These are similar to Pyret check tests. If you're following the math workshop with this programming workshop, you will have no problem understanding their examples of 'point-to reasoning'. It's similar to the proofs we've done in Tao's <i>Analysis</i>, you are listing reasons why something is true by pointing out which axiom or lemma gives it to you. The first <i>learn by doing</i> question has a bug, look at the actual assertion statement and not the 'The assertion x!= 8 is valid' title as sometimes the assertion is x!=20 if you reset the question.
</p>

<p>
Module 2 <i>Conditionals</i> the syntax of [0, 14) which is standard interval <a href="https://en.wikipedia.org/wiki/Bracket_(mathematics)#Intervals">notation</a> for inclusive/exclusive. In the example of @assert x==y, note we are using int's and not floats or roughnums so this assertion is true. If you get stuck on the nested conditionals question notice the @requries x &lt; 10, and if 4 &lt; x makes the nested x &lt;= 16 statement a waste of code. Let's continue on to the <i>Assignments</i> module, the example of if (e &gt; 0) { e = e - 1;.. note again these are integers, so the input can't be 0.5 or a 'half number' that makes e negative after 1 is subtracted. This is a little confusing because they are mixing assignment statements '=' with equality statements in working out their point-to reasoning. The very last assignment took some word smithing, x' + y' &gt; 2 * n. The last question to rewrite the assertion without using primed variables just substitute exactly what x and y are into x + y &gt; 2 * n, which is (x * 2) + x &gt; 2 * n. 
</p>
</div>
</div>

<div id="outline-container-org7d2ed87" class="outline-3">
<h3 id="org7d2ed87">Loops</h3>
<div class="outline-text-3" id="text-org7d2ed87">
<p>
Module 2: <i>Introduction to Loops</i> when you mutate data many things can go wrong, so learning how to reason about correct loops will be important to us should we go on to use a Python or some other AI library later. The first example the while loop you can hand step this loop, adjust the varibles with each iteration, then compare them to the assert such as @assert i &gt;=n once the loop exits, since if n = 3, then i should equal 3. Invariants are talked about but not introduced yet, these will be critical to know. An invariant is something that remains constant and doesn't change. 
</p>

<p>
Module 3: <i>Postconditions</i> or what can be shown to be true after a function returns. The first learn by doing example note the brackets that C0 uses to declare scope, you want your first assignment within the first bracket:
</p>

<pre class="example">
int endless_subtraction(int x, int y)
//@requires x &gt; 0;
//@ensures \result &lt; y;
{
  int temp = y;
  while (temp &gt; 0) {
    temp = temp - x;
  }
  return temp;
}
</pre>

<p>
For the next assignment, an example of the @ensures syntax:
</p>

<pre class="example">
//@ensures \result &gt; 0 &amp;&amp; \result % 2 == 0
//@ensures \result == x || \result == -x
</pre>

<p>
In <i>Contract Exploits</i>, I couldn't get the gcd() function exercise to accept my answer: 
</p>

<pre class="example">
//@ensures \result % x == 0 &amp;&amp; \result % y == 0;

However it does accept as correct answer:
//@ensures x % \result == 0 &amp;&amp; y % \result == 0;
</pre>
</div>
</div>

<div id="outline-container-org7190f29" class="outline-3">
<h3 id="org7190f29">Testing</h3>
<div class="outline-text-3" id="text-org7190f29">
<p>
Module 3 <i>Introduction to Testing</i> I had no problems answering all the assignments correctly the first time, a testament to the greatness of CS019/PAPL. For the edge cases I used gcd(1, 10) and gcd(10, 1), for the factorial function I used fact(0) is 1. There's numerous pow(base, exp) function edge cases you can come up with like pow(0,2) is 0. 
</p>

<p>
<i>Specification Functions</i> module is interesting, writing an inefficient secondary correct function to test a much faster implementation, or a secondary function to quickly test the result. I used 100,10 as inputs to the incorrect gcd. It uses a for loop, something the text didn't discuss at all before using it but you can probably figure it out anyway (for loops are covered in Module 10). First i is declared and assigned to 1, this is the index. A condition: i must be less or equal to x and i must be less or equal to y for the loop to continue. On each iteration increment i with i++ until i's value doesn't pass the loop condition. This is a completely incorrect implementation for example purposes.
</p>
</div>
</div>

<div id="outline-container-orgf2e39b8" class="outline-3">
<h3 id="orgf2e39b8">Proving Correctness</h3>
<div class="outline-text-3" id="text-orgf2e39b8">
<p>
Module 4 <i>Proving Correctness</i> let's learn about invariants and correctness proofs. The exercise in <i>Reasoning about Loop Invariants</i> for int test(int lo, int hi) my answers if you're stuck were lo &lt;= i', lo &lt;= i + 1, and i + 1 &lt;= hi. I couldn't get the system to accept i' &lt;= hi which it should be, if the condition on line 10 is i + 1 &lt;= hi. It does however accept i &lt;= hi (without the prime). We found another exercise bug. 
</p>

<p>
Aside: It's sometimes beneficial to have a few bugs in these kinds of courses, because you then challenge your own answer and go through the material again to prove your answer is correct. You'll experience this if you ever use an international version of a popular university textbook which typically sell for only 10% the regular cost. Almost always the end of chapter exercises will have been rewritten by some contractor to force students to buy the full priced version, as often the exercises will be assigned homework. Since the publisher doesn't care at all about the international version it will likely be filled with errata/mistakes in these exercises. You will have to dig deep into the material in order to assure yourself that you have the correct answer and the text is wrong. It also keeps you awake while going through the material.
</p>

<p>
There's another mistake in the very last point-to reasoning question in <i>Proving Correctness</i>, the second loop invariant should be i &lt;= hi instead of lo &lt;= i. In <i>Termination</i> the answers are a little tricky, i + 5 doesn't really make any sense but is still valid since i is decreasing. <i>Proving Functions Correct</i> the last module is very short but enough to put all this material together. Congrats you now know how to reason about a program that mutates it's variables.
</p>
</div>
</div>

<div id="outline-container-org23ea413" class="outline-3">
<h3 id="org23ea413">Arrays</h3>
<div class="outline-text-3" id="text-org23ea413">
<p>
Since we're on a roll let's just finish this entire course, starting with Module 8 <i>C0 Memory Model for Simple Types</i>. In <i>Function Calls</i> in a C program main() is called first, which is usually at the bottom. The first learn by doing exercise you are only determining what fast pow is being called with (parameters), so x and y. The second is hand stepping the function one iteration. You can see how difficult this can become, trying to keep the entire state of a program's variables in your head. In Pyret and other functional languages you don't have to do this, since variables are immutable. The recursion module should be easy to figure out since we've already done a lot of recursion with Pyret. 
</p>

<p>
The first array exercise actually runs your code, this was mine, note we are using booleans, so &amp;&amp;, || or !.
</p>
<details>
<pre class="example">
bool[] B = alloc_array(bool, 4);
B[0] = b;
B[1] = !B[0];
B[2] = B[0] &amp;&amp; B[1];
B[3] = B[1] || B[0];
</pre>
</details>

<p>
The second array exercise also runs your code, I just copied the examples for int[]:
</p>

<details>
<pre class="example">
char[][] C = alloc_array(char[], 3);
for (int i = 0; i &lt; 3; i++) {
    C[i] = alloc_array(char, 2);
}
C[0][0] = 'a';
C[0][1] = 'b';
C[1][0] = 'c';
C[1][1] = 'd';
C[2][0] = 'e';
C[2][1] = 'f';
</pre>
</details>

<p>
In Module 9 <i>The C0 Memory Model</i> the first assignment asks you to open the c0 interpreter and find out what the default initialized value is for an array of type boolean. I guessed it was false instead of using the interpreter since false would be the obvious design choice. You can try the online interpreter for c0 <a href="https://c0.surge.sh/">here</a>. At the end of this module they example a contract calling a helper function with \length(A) being used as an input in order to find the length of the array, with a warning that this is a hacky method that won't work if contracts aren't enabled in production since that assert statement won't be run. 
</p>
</div>
</div>

<div id="outline-container-org47a9647" class="outline-3">
<h3 id="org47a9647">Aliasing</h3>
<div class="outline-text-3" id="text-org47a9647">
<p>
Scope and aliasing can be difficult topics to learn, as per this paper on <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/tfk-stu-underst-alias-proc-calls/">Prof Shriram</a>'s Brown Univeristy page where upper-level students even failed to understand aliasing. That paper is worth looking at, to see how confusing this can become in some languages like Java where one change affects two different locations, as they both point to the same thing. The exercises on this page can get tricky, remember that A <code>= B if true means array A and B share the shame memory location and are thus the same array. A[1] =</code> B[1] if true means the values stored at those indexes are the same. 
</p>

<p>
Moving on to module 10 <i>Coding with Arrays</i> we run into more aliasing. Here they decide to introduce for loops even though they were already used previously. The main difference between a while loop and a for loop, is you want to use a for loop when the range is known, and a while loop for unknown amounts of loops, such as waiting for a user to enter a key, or summing an arbitrary amount of inputs. Since an array is a fixed range you'd use a for loop for our array copy program.  The learn by doing for summing an array, all you need to do here is declare int sum = 0 then in the body of the for loop keep a running sum, returning it outside the loop. Better code you'd have an if test to see if n == 0 then return 0 (sum of an empty array) but I didn't bother and it accepted my answer anyway. 
</p>

<details>
<pre class="example">
int sum = 0; 
for(int i = 0; i &lt; n; i++) {
   sum += A[i];
}
return sum;
// grader doesn't like sum = sum + A[i], preferring the += syntax instead


//the 'did I get this' exercise
int sum = 0;
for(int i = 0; i &lt; n; i++) {
   sum += i;
}
return sum;
//note the 'between 0 and n' meaning exclusive of n

</pre>
</details>

<p>
In <i>Safety of Array Code</i> you can see how difficult this can become to prove safety such as needing to guarantee the loop never reaches INT MAX. The very last <i>did I get this</i> question asks you to prove access to B[i] is safe, which there is only one answer and what we just covered in this module (the loop invariant). The rest of the exercises get harder and harder, but you will eventually figure them out and get better at 'point to reasoning'. For example the reasoning in array copy after the postcondition is added, how can we prove the postcondition is correct: if array B is created with length of n, and returned, then the postcondition must be correct. In <i>Correctness of Array Code</i> I couldn't get the system to accept my answer, which was originally A[i] == B[i] and return true, false otherwise. The accepted answer is to check if they don't equal, return true otherwise:
</p>

<pre class="example">
bool is_same_array(int[] A, int[] B, int n)
 //@requires n == \length(A) &amp;&amp; n == \length(B)
{ 
 for (int i = 0; i &lt; n; i++) 
 //@loop_invariant 0 &lt;= i
 {
   if (A[i] != B[i]) 
   return false; 
  } 
  
  return true;
}
</pre>

<p>
For Module 10 <i>Contract Exploits w/Array Code</i> the learn by doing assignment just wants you to write assert statements such as assert(A[0] == 0);, checking A's elements are not modified by array copy. 
</p>
</div>
</div>

<div id="outline-container-orgac755cf" class="outline-3">
<h3 id="orgac755cf">Searching and Sorting</h3>
<div class="outline-text-3" id="text-orgac755cf">
<p>
The loop invariant in the first search function '0 <code>= i' is suspect, as that invariant will be broken the first iteration. From the assignment questions this appears to be a typo, that it should read 0 &lt;</code> i instead. In Module 11 this is a confirmed typo, as the same function is repeated but with the fixed invariant. The first search learn by doing there's a few typos you'll catch, like search(100, x, A, 0, 10) when our search function only takes 4 parameters not 5. The last exercise in <i>Searching in a sorted Array</i> is easy once you've done the other exercises, only the 3rd line was a problem which was assert that A[i] &lt; x, a kind of pointless assertion since if A[i] is not x, and A[i] is not bigger than x (remember it's a sorted array), then our present iteration of A[i] must be less than x. In <i>Reasoning about the search function</i> the first exercise any function calls in the requires/ensures/assert contracts need to be checked for safety violations, and any statement accessing arrays in the @ensures postconditions, assert contracts or body of the code. The feedback for the correct answer on the last exercise is wrong but by now you should be pretty good at point to reasoning. The postcondition in the last exercise is correct because the array has a precondition that it's already sorted, there's a loop invariant that the desired value is not in the array so far making a call to a boolean function with the current value of i, there's 2 assert statements and an if block that if A[current loop index] is bigger than x, then clearly x isn't in the array since it's a sorted array. 
</p>

<p>
At this point, believe it or not, you know all there is to know about basic imperative programming and can go through the docs of any mainstream language like Python3.x for a future AI course. What we didn't cover was manual C pointers which if you wanted could go through the slides of the full 15-122 <a href="https://www.cs.cmu.edu/~15122/schedule.shtml">course</a> or try a systems <a href="https://functionalcs.github.io/curriculum/#orgf43f5fd">course</a> that shows how these pointers work at the assembly level. Since we care about AI and will likely be using Python soon this course was a great intro to reasoning about code that mutates memory. 
</p>
</div>
</div>

<div id="outline-container-org721a883" class="outline-3">
<h3 id="org721a883">Complexity</h3>
<div class="outline-text-3" id="text-org721a883">
<p>
We made it to the last unit on complexity. 
</p>
</div>
</div>
</div>



<div id="outline-container-org99637f5" class="outline-2">
<h2 id="org99637f5">Cryptopals challenges</h2>
<div class="outline-text-2" id="text-org99637f5">
<p>
Using only what we know so far (how to read Pyret docs, how to use higher order function) try completing a few of the <a href="https://cryptopals.com/">cryptopals</a> challenges to learn about how real-world crypto is attacked. Model the bytes however you want, I used strings because we haven't covered making our own datatypes yet for type binary, and if you use numbers Pyret will truncate binary 0001 to just 1. These challenges were designed so you write most of the modeling yourself.
</p>

<p>
Before you begin, you probably need to know the basics of bytes, boolean algebra and hex encoding. See 15-122 Imperative Programming.
</p>

<p>
<a href="https://cryptopals.com/sets/1/challenges/1">Challenge 1</a> - Convert hex to base64: we're given two encoded strings, one encoded in hex and the other in base64 and we are asked to operate only on raw bytes. Since we're using a web editor, I decided to model this with strings, and a string-dict which is in the Pyret documentation. Wikipedia has all the info needed to generate hex encoded or base64 which instead of 4 bits uses 6 bits, and has a padding scheme which is detailed <a href="https://en.wikipedia.org/wiki/Base64#Examples">here</a>. In that example, the character 'M' is 0100 1101 (8 bits) but base64 is 6 bits, so it pads four zeros for a total of 12 bits for the encoding which will be 2 base64 characters. You can check for this with built-in <a href="https://www.pyret.org/docs/latest/numbers.html#(part._numbers_num-modulo)">num-modulo</a>. If you're wondering how num-modulo(-7, 3) is 2, see this short <a href="https://www.youtube.com/watch?v=XRYsae9g3i8&amp;feature=youtu.be">video</a> on the mod operator. The first largest value of 3 bigger than -7 is -9, and the result is the distance between them which is 2. 
</p>

<details>
<pre class="example">
include string-dict

hex-to-binary-dict =
  [string-dict:
    "0", "0000",
    "1", "0001",
    "2", "0010",
    "3", "0011",
    "4", "0100",
    "5", "0101",
    "6", "0110",
    "7", "0111",
    "8", "1000",
    "9", "1001",
    "a", "1010",
    "b", "1011",
    "c", "1100",
    "d", "1101",
    "e", "1110",
    "f", "1111"]

binary-to-hex-dict =
  [string-dict:
    "0000", "0",
    "0001", "1",
    "0010", "2",
    "0011", "3",
    "0100", "4",
    "0101", "5",
    "0110", "6",
    "0111", "7",
    "1000", "8",
    "1001", "9",
    "1010", "a",
    "1011", "b",
    "1100", "c",
    "1101", "d",
    "1110", "e",
    "1111", "f"]

binary-to-base64=
  [string-dict:
    "000000", "A",
    "010000", "Q",	
    "100000", "g", 
    "110000", "w",
    "000001", "B",
    "010001", "R",
    "100001", "h",
    "110001", "x",
    "000010", "C",
    "010010", "S",
    "100010", "i",
    "110010", "y",
    "000011", "D",
    "010011", "T",
    "100011", "j",
    "110011", "z",
    "000100", "E",	
    "010100", "U",
    "100100", "k",
    "110100", "0",
    "000101", "F",	
    "010101", "V",	
    "100101", "l",
    "110101", "1",
    "000110", "G",
    "010110", "W",
    "100110", "m",
    "110110", "2",
    "000111", "H",
    "010111", "X",
    "100111", "n",
    "110111", "3",
    "001000", "I",
    "011000", "Y",
    "101000"," o",
    "111000", "4",
    "001001", "J",
    "011001", "Z",
    "101001", "p",
    "111001", "5",
    "001010", "K",
    "011010", "a",
    "101010", "q",
    "111010", "6",
    "001011", "L",
    "011011", "b", 
    "101011", "r",
    "111011", "7",
    "001100", "M",
    "011100", "c",
    "101100", "s",
    "111100", "8",
    "001101", "N",
    "011101", "d",
    "101101", "t",
    "111101", "9",
    "001110", "O",
    "011110", "e",
    "101110", "u",
    "111110", "+",
    "001111", "P",
    "011111", "f",
    "101111", "v",
    "111111", "/"]
</pre>
</details>

<p>
Build a function that takes the hex string as input, and outputs the binary representation, such as using string-explode() to make a list out of each character, and then map over the exploded list with hex-to-binary-dict.get-value(x) (see documentation for string-dict). You could also write a function make-bytes() that turns an exploded list of single bits into 4, 6 or 8 bits. 
</p>

<pre class="example">
hex-string = "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"

&gt;&gt;hex-to-binary-list(hex-string)
[list:
"0100", "1001", "0010", "0111", "0110", "1101", "0010", "0000", "0110", "1011", "0110", "1001", "0110", "1100", "0110", "1100", "0110", "1001", "0110", "1110", "0110", "0111", "0010", "0000", "0111", "1001", "0110", "1111", "0111", "0101", "0111", "0010", "0010", "0000", "0110", "0010", "0111", "0010", "0110", "0001", "0110", "1001", "0110", "1110", "0010", "0000", "0110", "1100", "0110", "1001", "0110", "1011", "0110", "0101", "0010", "0000", "0110", "0001", "0010", "0000", "0111", "0000", "0110", "1111", "0110", "1001", "0111", "0011", "0110", "1111", "0110", "1110", "0110", "1111", "0111", "0101", "0111", "0011", "0010", "0000", "0110", "1101", "0111", "0101", "0111", "0011", "0110", "1000", "0111", "0010", "0110", "1111", "0110", "1111", "0110", "1101"]

&gt;&gt;hex-to-binary-string(hex-string)

"010010010010011101101101001000000110101101101001011011000110110001101001011011100110011100100000011110010110111101110101011100100010000001100010011100100110000101101001011011100010000001101100011010010110101101100101001000000110000100100000011100000110111101101001011100110110111101101110011011110111010101110011001000000110110101110101011100110110100001110010011011110110111101101101"
</pre>

<p>
In Challenge 3, trying to find out which character has been XOR'd against the given hex encoded string, you can see Norvig's <a href="https://norvig.com/mayzner.html">word frequency</a> post. Your program can take the 1 byte ASCII <a href="https://i.pinimg.com/originals/03/14/eb/0314ebabbc3f4a6a756828a78f40a98e.png">character</a> (ie: 01010000 is "P") and only test XOR'ing the common words, then checking if the result is a member of the much larger original. You avoid having to xor the entire original string every try. Use the repeat() function for strings to multiply a single character's byte representation to the same size of the word's byte representation. Map2 over them with your own xor function. 
</p>

<p>
TODO
</p>
</div>
</div>

<div id="outline-container-orga79c99f" class="outline-2">
<h2 id="orga79c99f">Lecture 4 CS019</h2>
<div class="outline-text-2" id="text-orga79c99f">
<p>
Watching the Fri 9/14/18 lecture on performance. The lambda notation, it's the same as our anonymous map function notation we already did. The setup in the beginning of the lecture is to distinguish the notation in O(n) as being a function that maps from n -&gt; steps to complete computation. Another explanation is <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#(part._.Ambiguities_in_mathematics)">here</a> in <i>ambiguities in mathematics</i>.  
</p>

<p>
The constant mentioned at the end of the lecture in the formal notation is further exampled <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#(part._.A_formal_definition)">here</a>. It's a factor that bounds f, so no matter what input to f(k), a constant c times g(k) will be bigger or equal to it. What times k is bigger or equal to 5k + 4:
</p>

<ul class="org-ul">
<li>f(k) -&gt; 5k + 4:
<ul class="org-ul">
<li>5(1) + 4 = 9  (length 1)</li>
<li>5(2) + 4 = 14 (length 2)</li>
<li>5(3) + 4 = 19 (length 3)</li>
<li>5(10) + 4 = 54 (length 10)</li>
</ul></li>

<li>g(k) -&gt; k:
<ul class="org-ul">
<li>g(1) = 1</li>
<li>g(2) = 2</li>
<li>g(3) = 3</li>
</ul></li>
</ul>

<p>
To find the constant c, for all n &gt; k, you could pick 10 as suggested in the lecture, if k = 1 then we need a constant to make g(k) bigger or equal to all values greater than k.  
</p>

<ul class="org-ul">
<li>f(1) = 9</li>
<li>g(1) = 1
<ul class="org-ul">
<li>10 * g(1) is 10 and f &lt; g</li>
</ul></li>
<li>f(2) = 14</li>
<li>g(2) = 2
<ul class="org-ul">
<li>10 * g(2) is 20 and f &lt; g</li>
</ul></li>
<li>f(10) = 54</li>
<li>g(10) = 10
<ul class="org-ul">
<li>10 * g(10) is 100 and f &lt; g</li>
</ul></li>
</ul>

<p>
Be aware in algorithm analysis you will rarely have to find the constant and solve inequalities because as per this <a href="https://cs.uwaterloo.ca/~plragde/flaneries/FDS/Tools_and_Techniques.html#(part._.A_formal_definition)">book</a> chapter on formal notation <i>we rarely count exactly and then make things more imprecise</i>. This is just to understand how the big-O complexity model of f(n) \(\le\) c * g(n) work.
</p>
</div>
</div>
</div>
</body>
</html>
